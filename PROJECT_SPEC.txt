HV Trigger Async — Reproducible System Specification

1) Purpose & Scope
- Goal: A small, self‑hosted controller that safely “arms” and triggers a high‑voltage discharge device via a networked HTML UI or API.
- Constraints: Simple, robust, low‑latency; interlock system present at both front-end and on-mcu-backend tightly integrated with routine/s responsible for pulling fire GPIO high - never fire unless explicitly armed; persist user configuration across power cycles; provide Arduino-compatible OTA firmware update capability.
- Portability: This document defines behavior, protocols, and timing in platform‑agnostic terms so the system can be rebuilt in any language or on any MCU/SoC.

2) Hardware Abstraction (Platform‑agnostic)
- Outputs:
  - TRIGGER_OUT: digital output, active HIGH; drives HV trigger interface through appropriate isolation. Trigger is an N-channel mosfet drain-coupled via AC coupling LPF to pull the trigger pin of a 555 chip LOW upon fire command.
  - LED_READY_GREEN: ON when a control client is connected via WebSocket; otherwise used for network status (see Indicators).
  - LED_WAIT_AMBER: indicates Wi‑Fi wait/partial connectivity (see Indicators).
  - LED_PULSE_BLUE: indicates pulse activity (mirrors TRIGGER_OUT timing; may enforce minimum visible on & off‑time).
  - LED_ARMED_RED: slow blink whilst armed, NOT-mirrors BLUE LED during firing events.
- Optional Inputs: None required; an ADC may be reserved for future telemetry; treat as 0 if not available.
- Electrical: Debounce is not required on outputs. Ensure proper isolation for HV path. LEDs are present on pins as defined in pin_assignments.txt.

3) Operational Modes & Timing
- Fire modes:
  - single: Output a single HIGH pulse for width_ms.
  - buzz: Emit a buzz sequence per repetition: 10 sub‑pulses; each sub‑pulse is HIGH for width_ms then LOW; sub‑pulses are separated by spacing_ms; repetitions are separated by repeat_interval_ms.
- Parameters (runtime configurable, persisted):
  - width_ms: 5–100 (default 10)
  - spacing_ms: 10–100 (default 20)
  - repeat: 1–4 (default 1)
  - repeat_interval_ms: 50-1000 (default 150)
- Guard timing: If width_ms < 50, enforce an extra LOW delay to achieve at least 50 ms between successive HIGH operations (for visibility and power integrity).
- Telemetry tick: ~250 ms (configurable) for periodic state broadcast to be used both for logging by external processes and for telemetry feedback display and accurate interlock operation inside web UI.

4) Safety Model & State Machine
- States: DISARMED → ARMED → FIRING → DISARMED (auto after completion).
- Transitions:
  - DISARMED → ARMED: on Arm command; snapshot current configuration.
  - ARMED → FIRING: on Fire command; ignored if already FIRING.
  - FIRING → DISARMED: automatically upon completion (auto‑disarm) or on explicit Disarm by user via UI button.
- Rules:
  - Configuration changes (mode/width/spacing/repeat) are rejected while ARMED.
  - Fire is rejected unless ARMED and not FIRING.
  - All command results are reflected by the next telemetry frame. Should be confirmed as such by UI software else an error state is triggered and logged, prompting user to reinitialise or ignore.

5) Network Topology & Services
- Access Point (AP): Device hosts a Wi‑Fi SoftAP, default IPv4 10.11.12.1/24.
- Optional AP+STA: Device may also join a configured infrastructure SSID concurrently. Telemetry reports STA connectivity and IP when joined.
- HTTP service (port 80): Serves a minimal control UI (optional; API alone is sufficient).
- WebSocket (path /ws): Primary control channel for commands and telemetry.
- OTA (can be culled if storage/memory insufficient): Firmware update over network (default TCP port 3232). Requires an OTA‑capable partition layout on platforms that need it.

6) WebSocket Protocol (Canonical)
- Transport: WebSocket, text frames, JSON payloads, no newlines in frames.
- Telemetry (push ~250 ms and after commands):
  {
    "type": "state",
    "armed": false,
    "pulseActive": false,
    "pageCount": 0,                    // optional page load counter if UI served
    "wifiClients": 0,                   // connected AP stations
    "wifiConnected": false,             // true if any WS clients are connected
    "staConnected": false,              // AP+STA only
    "staIP": "",                        // AP+STA only
    "adc": 0,                           // reserved, 0 if unused
    "cfg": { "mode": "single|buzz", "width": 10, "spacing": 20, "repeat": 1 }
  }
- Commands (client → device):
  1) Arm/Disarm: { "cmd": "arm", "on": true|false }
  2) Configure (ignored when armed): { "cmd": "cfg", "mode": "single|buzz", "width": 5..100, "spacing": 10..100, "repeat": 1..4 }
  3) Fire (armed only): { "cmd": "fire" }
- Behavior:
  - After any valid command, device pushes a fresh telemetry frame.
  - Unknown fields are ignored but buffered and made available for logging via WS; unknown commands are no‑ops.

7) Indicators (Normative Behavior)
- Network/Ready LEDs:
  - If >=1 WS client connected: LED_READY_GREEN = ON (steady), LED_WAIT_AMBER = OFF.
  - Else if AP station count == 0: LED_WAIT_AMBER = slow blink (500ms on, 300ms off) LED_READY_GREEN = OFF.
  - Else (some AP stations, no WS): Alternate AMBER/GREEN to signal partial connectivity at a rate equivalent to a 200ms on-time for each colour.
- Armed LED:
  - ARMED: blink ~0.1 Hz; DISARMED: OFF. FIRING: alternates with Pulse LED; logical-NOT of Pulse LED during fire events.
- Pulse LED:
  - Mirrors TRIGGER_OUT HIGH while firing (both single and buzz sequences).

8) Persistence
- Store configuration (mode, width_ms, spacing_ms, repeat) in non‑volatile storage under a stable namespace.
- Load on boot before servicing network requests.
- Write through on configuration changes that are accepted (i.e., DISARMED only).

9) UI Requirements (Optional Reference Implementation)
- Client controls:
  - Mode: select [single|buzz] (radio)
  - Width: range 5..100 ms	(slider, 10ms increments)
  - Spacing: range 10..100 ms (slider, 5ms increments)
  - Repeat: range 1..4 (drop-down, default 1)
  - Arm: (gates firing)(somewhat less prominent than FIRE), coloured GREEN
  - Disarm: (similar prominence to ARM), clears ARMED state, re-enables controls, disables FIRE button
  - FIRE button: Prominent, central, defaults to disabled and visually reflects its enabled/disabled status. RED in colour when armed, light red when disarmed.
- Behavior:
  - While ARMED: sliders disabled; FIRE enabled.
  - While DISARMED: sliders enabled; FIRE disabled.
  - Bottom LCD-influenced “status bar”: AP stations, WS status, Armed state, Mode, Width, Spacing, Repeat.
  - enable FIRE immediately after sending Arm, remain consistent with telemetry.

10) Concurrency & Responsiveness
- The “fire” routine must not block request processing:
  - Run pulse generation in a separate task/thread/timer/ISR that leaves the event loop responsive.
  - Broadcast state during loop ticks; avoid pushing frames inside tight timing sections.
- Use message queues or atomic flags to communicate between network layer and timing layer.
- It is of high importance that the UI at the web interface remain in synchronisation with the current state of the incoming telemetry, which must itself only ever reflect the true state of the control routine, else error state is reported in status bar. include checks to ensure state and value consistency/lock in a holistic manner

11) OTA Update (Unless memory insufficient or CPU availability insufficient)
- Service an OTA agent on TCP port 3232 (or similar) concurrently with HTTP/WS.
- Platform‑specific: choose an OTA‑capable partition scheme (e.g., “default” A/B on ESP32) and ensure adequate free space.
- UX: report OTA start/progress/end and errors to the serial log.

12) Security & Safety
- Change default SoftAP password for field use.
- Treat TRIGGER_OUT as live hardware; test with a dummy load before connecting to HV.
- Consider adding a physical interlock/arming switch for extra safety.
- Limit exposure: run AP isolated; if enabling STA, restrict access (WPA2+ strong passphrase, VLANs, or IP allow‑lists).

13) Reference Timing (Pseudo‑logic)
- DISPATCH LOOP (every ~250 ms):
  - Push telemetry frame to all WS clients.
  - Update indicators (based on AP station count and WS client count).
  - Poll OTA handler (if present).
- FIRING (single):
  - TRIGGER_OUT = HIGH; LED_PULSE_BLUE = HIGH; delay width_ms
  - TRIGGER_OUT = LOW; LED_PULSE_BLUE = LOW
  - If width_ms < 50: ensure additional LOW delay to total ~50 ms
  - Auto‑disarm
- FIRING (buzz):
  - Repeat for r in 1..repeat:
    - For i in 1..10:
      - HIGH for width_ms, then LOW
      - If width_ms < 50: add extra LOW delay to reach ~50 ms
      - If i<10: delay spacing_ms
    - If r<repeat: delay spacing_ms
  - Auto‑disarm

14) Serial Logging (Recommended)
- Boot: libraries ready, pins configured, AP started (IP), STA join attempts and results.
- HTTP: route hits (e.g., GET /), client IPs.
- WebSocket: connect/disconnect events, message bodies received, JSON parse errors.
- Actions: CFG (with values), ARM on/off (with snapshot), FIRE start/completed.

15) Minimal “Any‑Language” Implementation Plan
- Step 1: Hardware Abstraction Layer (HAL)
  - Map TRIGGER_OUT and LED pins to target platform using pin_assignments.txt if present; implement digitalWrite/read and millisecond delays.
  - Provide a non‑blocking scheduler (event loop + periodic tick + worker task for firing).
- Step 2: Storage
  - Implement a small persistent KV store (mode, width, spacing, repeat); load on boot; write on accepted cfg updates.
- Step 3: Network
  - Bring up SoftAP (and optional STA) with a static IP (10.11.12.1/24 or platform equivalent).
  - Start HTTP (port 80) and WS (/ws) services. Serve a minimal HTML UI (optional).
- Step 4: Protocol & State
  - Implement WS message handling for arm/cfg/fire; enforce state machine rules.
  - Push telemetry frames on a fixed tick and after each command.
- Step 5: Fire Engine
  - Implement the timing routines for single and buzz modes with repeat and guard timing.
  - Ensure the engine runs independently of the network loop.
- Step 6: Indicators
  - Implement LED rules for network, armed, and pulse status.
- Step 7: OTA (optional)
  - Add OTA server (e.g., TCP/3232); ensure partitioning and concurrency with HTTP.
- Step 8: Test & Validate
  - Unit test the state machine; bench test timing with a logic analyzer; end‑to‑end WS tests.

16) Example Pin Mapping (Current ESP32‑CAM Build)
- TRIGGER_OUT = GPIO16 (active HIGH)
- LED_WAIT_AMBER = GPIO14
- LED_READY_GREEN = GPIO15
- LED_PULSE_BLUE = GPIO13
- LED_ARMED_RED = GPIO12
- SoftAP SSID = "Trigger-Remote", pass = "lollipop", IP = 10.11.12.1/24
- WebSocket path = /ws; HTTP = port 80; OTA = TCP 3232

17) Acceptance Criteria
- Disarmed by default on boot; configuration loaded and reflected in telemetry.
- Arm → Fire → Auto‑disarm cycle behaves exactly as specified for both modes and all parameter bounds.
- LED behavior matches rules for all connectivity and armed/firing states.
- Telemetry reflects reality (cfg, armed, pulseActive, Wi‑Fi/WS status) at ~250 ms cadence.
- Config updates while armed are rejected and do not alter the firing snapshot.
- OTA updates do not disrupt HTTP/WS when idle and complete with progress logs.

18) Extensibility Notes
- Multi‑channel outputs: replicate the Fire Engine with per‑channel configs; include channel id in WS messages.
- Authentication: add a shared token or per‑session pairing for WS commands.
- Alternative transports: CoAP/UDP or BLE GATT with equivalent state and command semantics.

